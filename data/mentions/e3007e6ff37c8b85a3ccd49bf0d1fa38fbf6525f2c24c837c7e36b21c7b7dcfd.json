[{"type":"entry","author":{"type":"card","name":"","photo":"","url":""},"url":"https://www.mybooam.tech/news/22621/2020/05/12/a-recipe-is-just-a-directed-acyclic-graph/","published":"2020-05-12T00:00:00","wm-received":"2020-05-12T20:36:01Z","wm-id":795482,"wm-source":"https://www.mybooam.tech/news/22621/2020/05/12/a-recipe-is-just-a-directed-acyclic-graph/","wm-target":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-protocol":"pingback","name":"A recipe is just a directed acyclic graph","content":{"html":"<a href=\"http://news.ycombinator.com/submitlink?u=https%3A%2F%2Fwww.mybooam.tech%2Fnews%2F22621%2F2020%2F05%2F12%2Fa-recipe-is-just-a-directed-acyclic-graph%2F&amp;t=A+recipe+is+just+a+directed+acyclic+graph\">\n<img src=\"https://image.ibb.co/hbeWwz/hn.jpg\" alt=\"hn.jpg\" /><br /><span>Send to HN</span>\n</a>\n\n<p>Written by <a href=\"https://bofh.org.uk/\"><span>Piers</span> <span>Cawley</span></a> on<br /><time datetime=\"2019-03-04T00:00:00Z0000\">2019-03-04</time></p><p>In <a href=\"https://bofh.org.uk/2019/02/25/baking-with-emacs\">the last post</a> I handwaved the way I represented bakery formulae in the bakery database, so here’s a little more detail. It helps to think of a bakery formula as a node on a directed acyclic<br />\ngraph with weighted edges, where the weights are literally weights. Here’s the graph a for a  couple of products</p>\n<img src=\"https://bofh.org.uk/ox-hugo/formulae.svg\" alt=\"formulae.svg\" />\n<p>And here’s how we represent that in the database<br />\n:</p>\nname\ningredient\nformat\nSmall Seedy Malt\nSeedy Malt Dough\n0.63 kg\nSmall White Wild\nBasic White Sour\n0.63 kg\nBasic White Sour\nOrganic white flour\n2.00 kg\nBasic White Sour\nSea salt\n0.06 kg\nBasic White Sour\nWater\n1.10 kg\nBasic White Sour\n80% starter\n1.80 kg\nSeedy Malt Dough\n5 Seed Soaker\n4.00 kg\nSeedy Malt Dough\nWater\n3.80 kg\nSeedy Malt Dough\nSea salt\n0.22 kg\nSeedy Malt Dough\n80% starter\n3.60 kg\nSeedy Malt Dough\nOrganic light malthouse flour\n8.00 kg\n5 Seed Soaker\nWater\n1.20 kg\n5 Seed Soaker\n5 seed mix\n1.00 kg\nMother\nWater\n3.20 kg\nMother\nOrganic white flour\n4.00 kg\n\n<p>Suppose we have an order for 8 Small White loaves. We need to know how much starter to mix tonight. We know that we need 0.63 kg of dough for each loaf, so that’s a total of 5.04 kg of Basic White Sour. The formula for Basic White Sour makes a total of (1.10 + 1.80 + 0.06 + 2.00=4.96 mathrm{kg}) of dough. So we need to multiply each quantity in that formula by the weight of dough we need divided by the total weight of the recipe ((5.04/4.96=1.016)). This is straightforward enough for flour, water and salt, which are basic ingredients, but we’ll need to do a similar calculation to work out how much flour and water we’ll need to make (1.016 × 1.8=1.829 mathrm{kg}) of starter. You can see how this might become a little tedious.</p>\n<p>If I were going to be doing these calculations by hand, it would definitely pay me to normalize my intermediate formulae so they all made a total of 1 kg of stuff. But screw that, we have a computer, so we can make it do the work.</p>\n<p>I’m going to simplify things a little (the real database understands about dates, and we need to know a little more about recipes, products and ingredients than will fit in the <code>recipe_item</code> table that describes the graph) but this should give you an idea of the recursive queries that drive production planning.</p>\n<p>Let’s introduct a <code>production_order</code> table, where we stash our orders<br />\n:</p>\nproduct\nquantity\nSmall White Wild\n5\nSmall Seedy Malt\n5\n\n<p>And that’s all we need to fire off a recursive query<br />\n.</p>\n<pre><code><span>WITH</span> <span>RECURSIVE</span> po(product, quantity) <span>AS</span> (\n    <span>SELECT</span> <span>'Small White Wild'</span>, <span>5</span>\n  <span>UNION</span>\n    <span>SELECT</span> <span>'Large White Wild'</span>, <span>5</span>\n), rw(recipe, weight) <span>AS</span> (\n    <span>SELECT</span> recipe, <span>sum</span>(amount)\n      <span>FROM</span> bakehouse.recipe_item\n  <span>GROUP</span> <span>BY</span> recipe\n), job(product, ingredient, quantity) <span>AS</span> (\n    <span>SELECT</span> po.product,\n           ri.ingredient,\n           po.quantity <span>*</span> ri.amount\n      <span>FROM</span> po\n      <span>JOIN</span> bakehouse.recipe_item ri <span>ON</span> po.product <span>=</span> ri.recipe\n      <span>JOIN</span> rw <span>ON</span> ri.recipe <span>=</span> rw.recipe\n  <span>UNION</span>\n    <span>SELECT</span> job.ingredient, ri.ingredient, job.quantity <span>*</span> ri.amount <span>/</span> rw.weight\n      <span>FROM</span> job\n      <span>join</span> bakehouse.recipe_item ri <span>on</span> job.ingredient <span>=</span> ri.recipe\n      <span>join</span> rw <span>on</span> job.ingredient <span>=</span> rw.recipe\n)\n<span>SELECT</span> product formula, ingredient, ROUND(<span>sum</span>(quantity),<span>2</span>) quantity <span>from</span> job <span>group</span> <span>by</span> job.product, job.ingredient <span>order</span> <span>by</span> formula;\n</code></pre>\n<p>Which gives the following result:</p>\nformula\ningredient\nquantity\nBasic White Sour\nSea salt\n0.09\nBasic White Sour\nWater\n1.72\nBasic White Sour\nMother\n2.81\nBasic White Sour\nOrganic white flour\n3.13\nLarge White Wild\nBasic White Sour\n4.65\nMother\nOrganic white flour\n1.56\nMother\nWater\n1.25\nSmall White Wild\nBasic White Sour\n3.10\n\n<p>A quick sanity check seems to show this is correct (we’re making 7.75kg of Basic White Sour, which tallies with the weights needed to make the loaves).<br />\nSo what’s going on in the query? In SQL, <code>WITH</code> is a way of giving names to your intermediate results, akin to <code>let</code> in a Lisp. We fake up a table to hold our production orders (<code>po</code>) and the <code>rw</code> clause is totals the weights of all our recipes (in the real database, it’s a view). The magic really starts to happen when you use the <code>WITH RECURSIVE</code> form. With <code>RECURSIVE</code> in play, the last query is treated differently. Instead of being a simple two part <code>UNION</code> what happens is that we first run:</p>\n<pre><code><span>SELECT</span> po.product, ri.ingredient, po.quantity <span>*</span> ri.amount\n  <span>FROM</span> po\n  <span>JOIN</span> bakehouse.recipe_item ri <span>on</span> po.product <span>=</span> ri.recipe\n  <span>JOIN</span> rw <span>on</span> ri.recipe <span>=</span> rw.recipe\n</code></pre>\n<p>and call the results <code>job</code> and then run the second query, adding any extra rows generated to the results, and repeating that query until the result set stops growing. If we didn’t have <code>WITH RECURSIVE</code> available, and we knew the maximum depth of recursion we would need, we could fake it by making a bunch of intermediate clauses in our <code>WITH</code>. In fact, until I worked out how <code>WITH RECURSIVE</code> works, that’s exactly what I did.</p>\n<p>Have you spotted the mistake? I didn’t, until a few bakes when horribly wrong.</p>\n<p>Here’s what happens when we have an order for 3 small loaves and two large ones</p>\nformula\ningredient\nquantity\nBasic White Sour\nSea salt\n0.02\nBasic White Sour\nWater\n0.41\nBasic White Sour\nMother\n0.68\nBasic White Sour\nOrganic white flour\n0.75\nLarge White Wild\nBasic White Sour\n1.86\nMother\nOrganic white flour\n0.38\nMother\nWater\n0.30\nSmall White Wild\nBasic White Sour\n1.86\n\n<p>We’re only making 1.86 kg of dough? What’s going on?</p>\n<p>It turns out that the way a <code>UNION</code> works is akin to doing <code>SELECT DISTINCT</code> on the combined table, so it selects only unique rows. When two orders end up requiring exactly the same amount of the ‘same’ dough, they get smashed together and we lose half the weight. This is not ideal.<br />\nI fixed it by adding a ‘path’ to the query, keeping track of how we arrived at a particular formula. Something like:</p>\n<pre><code><span>WITH</span> <span>RECURSIVE</span> po(product, quantity) <span>AS</span> (\n    <span>SELECT</span> <span>'Small White Wild'</span>, <span>3</span>\n  <span>UNION</span>\n    <span>SELECT</span> <span>'Large White Wild'</span>, <span>2</span>\n), rw(recipe, weight) <span>AS</span> (\n    <span>SELECT</span> recipe, <span>sum</span>(amount)\n      <span>FROM</span> bakehouse.recipe_item\n  <span>GROUP</span> <span>BY</span> recipe\n), job(path, product, ingredient, quantity) <span>AS</span> (\n    <span>SELECT</span> po.product,\n           po.product,\n           ri.ingredient,\n           po.quantity <span>*</span> ri.amount\n      <span>FROM</span> po\n      <span>JOIN</span> bakehouse.recipe_item ri <span>ON</span> po.product <span>=</span> ri.recipe\n      <span>JOIN</span> rw <span>ON</span> ri.recipe <span>=</span> rw.recipe\n  <span>UNION</span>\n    <span>SELECT</span> job.path <span>||</span> <span>'.'</span> <span>||</span> job.ingredient,\n           job.ingredient,\n           ri.ingredient,\n           job.quantity <span>*</span> ri.amount <span>/</span> rw.weight\n      <span>FROM</span> job\n      <span>join</span> bakehouse.recipe_item ri <span>on</span> job.ingredient <span>=</span> ri.recipe\n      <span>join</span> rw <span>on</span> job.ingredient <span>=</span> rw.recipe\n)\n<span>SELECT</span> product formula, ingredient, round(<span>sum</span>(quantity),<span>2</span>) weight <span>from</span> job <span>group</span> <span>by</span> formula, ingredient <span>order</span> <span>by</span> formula;\n</code></pre>\n<p>This query gives us:</p>\nformula\ningredient\nweight\nBasic White Sour\nSea salt\n0.05\nBasic White Sour\nWater\n0.83\nBasic White Sour\nMother\n1.35\nBasic White Sour\nOrganic white flour\n1.50\nLarge White Wild\nBasic White Sour\n1.86\nMother\nOrganic white flour\n0.75\nMother\nWater\n0.60\nSmall White Wild\nBasic White Sour\n1.86\n\n<p>This time we’re making 3.74 kg of dough, which is right.</p>\n<p>In order to see what’s going on, we can change the final <code>SELECT</code> to <code>SELECT formula, path, ingredient, round(quantity,2) weight FROM job</code>, and now we get:</p>\nformula\npath\ningredient\nweight\nLarge White Wild\nLarge White Wild\nBasic White Sour\n1.86\nBasic White Sour\nLarge White Wild.Basic White Sour\nMother\n0.68\nBasic White Sour\nLarge White Wild.Basic White Sour\nOrganic white flour\n0.75\nBasic White Sour\nLarge White Wild.Basic White Sour\nWater\n0.41\nBasic White Sour\nLarge White Wild.Basic White Sour\nSea salt\n0.02\nMother\nLarge White Wild.Basic White Sour.Mother\nWater\n0.30\nMother\nLarge White Wild.Basic White Sour.Mother\nOrganic white flour\n0.38\nSmall White Wild\nSmall White Wild\nBasic White Sour\n1.86\nBasic White Sour\nSmall White Wild.Basic White Sour\nOrganic white flour\n0.75\nBasic White Sour\nSmall White Wild.Basic White Sour\nSea salt\n0.02\nBasic White Sour\nSmall White Wild.Basic White Sour\nWater\n0.41\nBasic White Sour\nSmall White Wild.Basic White Sour\nMother\n0.68\nMother\nSmall White Wild.Basic White Sour.Mother\nOrganic white flour\n0.38\nMother\nSmall White Wild.Basic White Sour.Mother\nWater\n0.30\n\n<p>Which shows that we’re considering two lots of Basic White Sour with exactly the same weights, but we (and more importantly, the database engine) know that they’re distinct amounts because we get to them through different routes. Hurrah! The problem is solved and we can accurately work out what we should be mixing.</p>\n<h2>What’s still missing</h2>\n<p>As a baker, I know  if I’ve got an order for bread on Friday, then I need to mix the starters on Wednesday night, then spend Tuesday mixing, fermenting and shaping the loaves, which will spend the night in the retarder ready to be baked at 4 on Friday morning. But the schema I’ve outlined here doesn’t. In my full bakehouse schema, I have a few extra tables which hold timing data and such. In particular, I have a <code>product</code> table, which knows about everything I sell. This table knows holds info about how many I can make per hour of work and the bake time and temperature. Then there’s a <code>recipe</code> table which holds information about how long a formula needs to rest<br />\n. The real queries take this into account to allow us to work back from the <code>due_date</code> of a real order to the day we need to do the work. If you want to dig into how I handle dates  you can check out the repository at <a href=\"https://github.com/pdcawley/bakehouse/\">https://github.com/pdcawley/bakehouse/</a>.</p>\n<p><a href=\"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/\">Read More</a></p>","text":"Send to HN\n\n\nWritten by Piers Cawley on\n2019-03-04In the last post I handwaved the way I represented bakery formulae in the bakery database, so here’s a little more detail. It helps to think of a bakery formula as a node on a directed acyclic\n\ngraph with weighted edges, where the weights are literally weights. Here’s the graph a for a  couple of products\nAnd here’s how we represent that in the database\n\n:\nname\ningredient\nformat\nSmall Seedy Malt\nSeedy Malt Dough\n0.63 kg\nSmall White Wild\nBasic White Sour\n0.63 kg\nBasic White Sour\nOrganic white flour\n2.00 kg\nBasic White Sour\nSea salt\n0.06 kg\nBasic White Sour\nWater\n1.10 kg\nBasic White Sour\n80% starter\n1.80 kg\nSeedy Malt Dough\n5 Seed Soaker\n4.00 kg\nSeedy Malt Dough\nWater\n3.80 kg\nSeedy Malt Dough\nSea salt\n0.22 kg\nSeedy Malt Dough\n80% starter\n3.60 kg\nSeedy Malt Dough\nOrganic light malthouse flour\n8.00 kg\n5 Seed Soaker\nWater\n1.20 kg\n5 Seed Soaker\n5 seed mix\n1.00 kg\nMother\nWater\n3.20 kg\nMother\nOrganic white flour\n4.00 kg\n\nSuppose we have an order for 8 Small White loaves. We need to know how much starter to mix tonight. We know that we need 0.63 kg of dough for each loaf, so that’s a total of 5.04 kg of Basic White Sour. The formula for Basic White Sour makes a total of (1.10 + 1.80 + 0.06 + 2.00=4.96 mathrm{kg}) of dough. So we need to multiply each quantity in that formula by the weight of dough we need divided by the total weight of the recipe ((5.04/4.96=1.016)). This is straightforward enough for flour, water and salt, which are basic ingredients, but we’ll need to do a similar calculation to work out how much flour and water we’ll need to make (1.016 × 1.8=1.829 mathrm{kg}) of starter. You can see how this might become a little tedious.\nIf I were going to be doing these calculations by hand, it would definitely pay me to normalize my intermediate formulae so they all made a total of 1 kg of stuff. But screw that, we have a computer, so we can make it do the work.\nI’m going to simplify things a little (the real database understands about dates, and we need to know a little more about recipes, products and ingredients than will fit in the recipe_item table that describes the graph) but this should give you an idea of the recursive queries that drive production planning.\nLet’s introduct a production_order table, where we stash our orders\n\n:\nproduct\nquantity\nSmall White Wild\n5\nSmall Seedy Malt\n5\n\nAnd that’s all we need to fire off a recursive query\n\n.\nWITH RECURSIVE po(product, quantity) AS (\n    SELECT 'Small White Wild', 5\n  UNION\n    SELECT 'Large White Wild', 5\n), rw(recipe, weight) AS (\n    SELECT recipe, sum(amount)\n      FROM bakehouse.recipe_item\n  GROUP BY recipe\n), job(product, ingredient, quantity) AS (\n    SELECT po.product,\n           ri.ingredient,\n           po.quantity * ri.amount\n      FROM po\n      JOIN bakehouse.recipe_item ri ON po.product = ri.recipe\n      JOIN rw ON ri.recipe = rw.recipe\n  UNION\n    SELECT job.ingredient, ri.ingredient, job.quantity * ri.amount / rw.weight\n      FROM job\n      join bakehouse.recipe_item ri on job.ingredient = ri.recipe\n      join rw on job.ingredient = rw.recipe\n)\nSELECT product formula, ingredient, ROUND(sum(quantity),2) quantity from job group by job.product, job.ingredient order by formula;\n\nWhich gives the following result:\nformula\ningredient\nquantity\nBasic White Sour\nSea salt\n0.09\nBasic White Sour\nWater\n1.72\nBasic White Sour\nMother\n2.81\nBasic White Sour\nOrganic white flour\n3.13\nLarge White Wild\nBasic White Sour\n4.65\nMother\nOrganic white flour\n1.56\nMother\nWater\n1.25\nSmall White Wild\nBasic White Sour\n3.10\n\nA quick sanity check seems to show this is correct (we’re making 7.75kg of Basic White Sour, which tallies with the weights needed to make the loaves).\n\nSo what’s going on in the query? In SQL, WITH is a way of giving names to your intermediate results, akin to let in a Lisp. We fake up a table to hold our production orders (po) and the rw clause is totals the weights of all our recipes (in the real database, it’s a view). The magic really starts to happen when you use the WITH RECURSIVE form. With RECURSIVE in play, the last query is treated differently. Instead of being a simple two part UNION what happens is that we first run:\nSELECT po.product, ri.ingredient, po.quantity * ri.amount\n  FROM po\n  JOIN bakehouse.recipe_item ri on po.product = ri.recipe\n  JOIN rw on ri.recipe = rw.recipe\n\nand call the results job and then run the second query, adding any extra rows generated to the results, and repeating that query until the result set stops growing. If we didn’t have WITH RECURSIVE available, and we knew the maximum depth of recursion we would need, we could fake it by making a bunch of intermediate clauses in our WITH. In fact, until I worked out how WITH RECURSIVE works, that’s exactly what I did.\nHave you spotted the mistake? I didn’t, until a few bakes when horribly wrong.\nHere’s what happens when we have an order for 3 small loaves and two large ones\nformula\ningredient\nquantity\nBasic White Sour\nSea salt\n0.02\nBasic White Sour\nWater\n0.41\nBasic White Sour\nMother\n0.68\nBasic White Sour\nOrganic white flour\n0.75\nLarge White Wild\nBasic White Sour\n1.86\nMother\nOrganic white flour\n0.38\nMother\nWater\n0.30\nSmall White Wild\nBasic White Sour\n1.86\n\nWe’re only making 1.86 kg of dough? What’s going on?\nIt turns out that the way a UNION works is akin to doing SELECT DISTINCT on the combined table, so it selects only unique rows. When two orders end up requiring exactly the same amount of the ‘same’ dough, they get smashed together and we lose half the weight. This is not ideal.\n\nI fixed it by adding a ‘path’ to the query, keeping track of how we arrived at a particular formula. Something like:\nWITH RECURSIVE po(product, quantity) AS (\n    SELECT 'Small White Wild', 3\n  UNION\n    SELECT 'Large White Wild', 2\n), rw(recipe, weight) AS (\n    SELECT recipe, sum(amount)\n      FROM bakehouse.recipe_item\n  GROUP BY recipe\n), job(path, product, ingredient, quantity) AS (\n    SELECT po.product,\n           po.product,\n           ri.ingredient,\n           po.quantity * ri.amount\n      FROM po\n      JOIN bakehouse.recipe_item ri ON po.product = ri.recipe\n      JOIN rw ON ri.recipe = rw.recipe\n  UNION\n    SELECT job.path || '.' || job.ingredient,\n           job.ingredient,\n           ri.ingredient,\n           job.quantity * ri.amount / rw.weight\n      FROM job\n      join bakehouse.recipe_item ri on job.ingredient = ri.recipe\n      join rw on job.ingredient = rw.recipe\n)\nSELECT product formula, ingredient, round(sum(quantity),2) weight from job group by formula, ingredient order by formula;\n\nThis query gives us:\nformula\ningredient\nweight\nBasic White Sour\nSea salt\n0.05\nBasic White Sour\nWater\n0.83\nBasic White Sour\nMother\n1.35\nBasic White Sour\nOrganic white flour\n1.50\nLarge White Wild\nBasic White Sour\n1.86\nMother\nOrganic white flour\n0.75\nMother\nWater\n0.60\nSmall White Wild\nBasic White Sour\n1.86\n\nThis time we’re making 3.74 kg of dough, which is right.\nIn order to see what’s going on, we can change the final SELECT to SELECT formula, path, ingredient, round(quantity,2) weight FROM job, and now we get:\nformula\npath\ningredient\nweight\nLarge White Wild\nLarge White Wild\nBasic White Sour\n1.86\nBasic White Sour\nLarge White Wild.Basic White Sour\nMother\n0.68\nBasic White Sour\nLarge White Wild.Basic White Sour\nOrganic white flour\n0.75\nBasic White Sour\nLarge White Wild.Basic White Sour\nWater\n0.41\nBasic White Sour\nLarge White Wild.Basic White Sour\nSea salt\n0.02\nMother\nLarge White Wild.Basic White Sour.Mother\nWater\n0.30\nMother\nLarge White Wild.Basic White Sour.Mother\nOrganic white flour\n0.38\nSmall White Wild\nSmall White Wild\nBasic White Sour\n1.86\nBasic White Sour\nSmall White Wild.Basic White Sour\nOrganic white flour\n0.75\nBasic White Sour\nSmall White Wild.Basic White Sour\nSea salt\n0.02\nBasic White Sour\nSmall White Wild.Basic White Sour\nWater\n0.41\nBasic White Sour\nSmall White Wild.Basic White Sour\nMother\n0.68\nMother\nSmall White Wild.Basic White Sour.Mother\nOrganic white flour\n0.38\nMother\nSmall White Wild.Basic White Sour.Mother\nWater\n0.30\n\nWhich shows that we’re considering two lots of Basic White Sour with exactly the same weights, but we (and more importantly, the database engine) know that they’re distinct amounts because we get to them through different routes. Hurrah! The problem is solved and we can accurately work out what we should be mixing.\nWhat’s still missing\nAs a baker, I know  if I’ve got an order for bread on Friday, then I need to mix the starters on Wednesday night, then spend Tuesday mixing, fermenting and shaping the loaves, which will spend the night in the retarder ready to be baked at 4 on Friday morning. But the schema I’ve outlined here doesn’t. In my full bakehouse schema, I have a few extra tables which hold timing data and such. In particular, I have a product table, which knows about everything I sell. This table knows holds info about how many I can make per hour of work and the bake time and temperature. Then there’s a recipe table which holds information about how long a formula needs to rest\n\n. The real queries take this into account to allow us to work back from the due_date of a real order to the day we need to do the work. If you want to dig into how I handle dates  you can check out the repository at https://github.com/pdcawley/bakehouse/.\nRead More"},"mention-of":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-property":"mention-of","wm-private":false,"rels":{"canonical":"https://www.mybooam.tech/news/22621/2020/05/12/a-recipe-is-just-a-directed-acyclic-graph/"}},{"type":"entry","author":{"type":"card","name":"Robert","photo":"https://mendeddrum.org/system/cache/accounts/avatars/109/365/823/867/664/496/original/5a56a58ddc9aeda0.jpg","url":"https://fosstodon.org/@rrwo"},"url":"https://mendeddrum.org/@pdcawley/109438438184832322#favorited-by-109365823867664496","published":null,"wm-received":"2022-12-01T13:07:56Z","wm-id":1572409,"wm-source":"https://brid.gy/like/mastodon/@pdcawley@mendeddrum.org/109438438184832322/109365823867664496","wm-target":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-protocol":"webmention","like-of":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-property":"like-of","wm-private":false},{"type":"entry","author":{"type":"card","name":"smcn 🏴󠁧󠁢󠁳󠁣󠁴󠁿🇵🇭","photo":"https://mendeddrum.org/system/cache/accounts/avatars/109/304/672/248/519/811/original/8e84a9576b9f8eb2.jpg","url":"https://fosstodon.org/@smcn"},"url":"https://mendeddrum.org/@pdcawley/109438438184832322#favorited-by-109304672248519811","published":null,"wm-received":"2022-12-01T13:08:57Z","wm-id":1572411,"wm-source":"https://brid.gy/like/mastodon/@pdcawley@mendeddrum.org/109438438184832322/109304672248519811","wm-target":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-protocol":"webmention","like-of":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-property":"like-of","wm-private":false},{"type":"entry","author":{"type":"card","name":"Christine Lemmer-Webber","photo":"https://mendeddrum.org/system/cache/accounts/avatars/109/274/050/804/101/523/original/49f78f66d4224521.jpg","url":"https://octodon.social/@cwebber"},"url":"https://mendeddrum.org/@pdcawley/109438438184832322#favorited-by-109274050804101523","published":null,"wm-received":"2022-12-01T14:37:53Z","wm-id":1572482,"wm-source":"https://brid.gy/like/mastodon/@pdcawley@mendeddrum.org/109438438184832322/109274050804101523","wm-target":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-protocol":"webmention","like-of":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-property":"like-of","wm-private":false},{"type":"entry","author":{"type":"card","name":"Christine Lemmer-Webber","photo":"https://mendeddrum.org/system/cache/accounts/avatars/109/274/050/804/101/523/original/49f78f66d4224521.jpg","url":"https://octodon.social/@cwebber"},"url":"https://mendeddrum.org/@pdcawley/109438438184832322#reblogged-by-109274050804101523","published":null,"wm-received":"2022-12-01T14:37:54Z","wm-id":1572483,"wm-source":"https://brid.gy/repost/mastodon/@pdcawley@mendeddrum.org/109438438184832322/109274050804101523","wm-target":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-protocol":"webmention","repost-of":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-property":"repost-of","wm-private":false},{"type":"entry","author":{"type":"card","name":"Devin Prater","photo":"https://mendeddrum.org/avatars/original/missing.png","url":"https://tweesecake.social/@devinprater"},"url":"https://mendeddrum.org/@pdcawley/109438438184832322#favorited-by-109336205615008232","published":null,"wm-received":"2022-12-01T16:10:41Z","wm-id":1572519,"wm-source":"https://brid.gy/like/mastodon/@pdcawley@mendeddrum.org/109438438184832322/109336205615008232","wm-target":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-protocol":"webmention","like-of":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-property":"like-of","wm-private":false},{"type":"entry","author":{"type":"card","name":"Devin Prater","photo":"https://mendeddrum.org/avatars/original/missing.png","url":"https://tweesecake.social/@devinprater"},"url":"https://mendeddrum.org/@pdcawley/109438438184832322#reblogged-by-109336205615008232","published":null,"wm-received":"2022-12-01T16:11:41Z","wm-id":1572520,"wm-source":"https://brid.gy/repost/mastodon/@pdcawley@mendeddrum.org/109438438184832322/109336205615008232","wm-target":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-protocol":"webmention","repost-of":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-property":"repost-of","wm-private":false},{"type":"entry","author":{"type":"card","name":"Akib Azmain Turja","photo":"https://mendeddrum.org/avatars/original/missing.png","url":"https://hostux.social/@akib"},"url":"https://mendeddrum.org/@pdcawley/109438438184832322#favorited-by-109309699960105764","published":null,"wm-received":"2022-12-01T17:38:36Z","wm-id":1572549,"wm-source":"https://brid.gy/like/mastodon/@pdcawley@mendeddrum.org/109438438184832322/109309699960105764","wm-target":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-protocol":"webmention","like-of":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-property":"like-of","wm-private":false},{"type":"entry","author":{"type":"card","name":"Akib Azmain Turja","photo":"https://mendeddrum.org/avatars/original/missing.png","url":"https://hostux.social/@akib"},"url":"https://mendeddrum.org/@pdcawley/109438438184832322#reblogged-by-109309699960105764","published":null,"wm-received":"2022-12-01T17:39:38Z","wm-id":1572552,"wm-source":"https://brid.gy/repost/mastodon/@pdcawley@mendeddrum.org/109438438184832322/109309699960105764","wm-target":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-protocol":"webmention","repost-of":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-property":"repost-of","wm-private":false},{"type":"entry","author":{"type":"card","name":"𝙿𝚒𝚡𝚎𝚕𝚊𝚝𝚎𝚍 𝔽𝕀𝕊𝕋","photo":"https://mendeddrum.org/system/cache/accounts/avatars/109/329/872/634/117/885/original/f888f041ffebd205.png","url":"https://fosstodon.org/@pixelatedfist"},"url":"https://mendeddrum.org/@pdcawley/109438438184832322#favorited-by-109329872634117885","published":null,"wm-received":"2022-12-01T21:28:40Z","wm-id":1572745,"wm-source":"https://brid.gy/like/mastodon/@pdcawley@mendeddrum.org/109438438184832322/109329872634117885","wm-target":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-protocol":"webmention","like-of":"https://bofh.org.uk/2019/03/04/recursive-sql-recipes/","wm-property":"like-of","wm-private":false}]