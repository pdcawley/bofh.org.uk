#+hugo_section: post/
#+hugo_base_dir: ../
#+export_hugo_weight: auto
#+hugo_auto_set_lastmod: t
#+startup: inlineimages
#+property: header-args:sql :session reporter :exports result :colnames yes  :engine postgresql :results replace table

#+seq_todo: TODO DRAFT DONE


* Bakehouse Diary :@bakehouse-diary:
  :properties:
  :export_hugo_custom_front_matter: :series "Bakehouse Diary"
  :end:

** Bakehouse Diary
   :properties:
   :export_file_name: back-to-the-bakehouse
   :export_date: [2018-02-01 Thu]
   :export_hugo_custom_front_matter: :description "Back to the bakehouse" :series "Bakehouse Diary"
   :end:

I know! It's been a while. But we're in! I have baked, and it was
good. There's still a ton of stuff to do (plumbing, mostly) but the
really important bits of kit are all in place and looking good.

We celebrated getting in by turning one of the decks up as high as it
would go and making lots of pizzas and a few loaves of bread.

#+attr_html: :width 100%
#+caption: An early pizza
[[./back-to-the-bakehouse/margherita-pizza.jpg]]

#+hugo: more

*** The story so far…

In my [[/2016/11/11/taking-stock/][last entry]] (over a year ago, argh! Gill is /much/ better) the
oven and all my kit were still in my garage, up on blocks waiting for
Dad to build an A-frame so we could winch it up and assemble it. Which
happened, and we managed to get one section of oven up onto the base.
And there we stopped because the fully assembled oven is very tall, and
the A-frame isn't tall enough to accommodate a fully assembled oven +
the winch + space for the straps (and my garage roof isn't high enough
to accommodate a sufficently tall A-frame). Still, it allowed us to
start in on prEocess of breaking the heads of very old brass
machine screws and generally failing to get the oven beds out where
they could be cleaned. This was frustrating, but it's not like I was
unused to frustration.

Meanwhile, the bakehouse site moved again. We had thought it would be
a relatively easy (and thus cheap) matter to run the necessary 3-phase
power to the space, but it turns out there wasn't quite enough power
going to the building to support what we needed. That would mean a new
substation and some very expensive cable laying. So it wasn't going to
fly. Luckily, there is also an old cafe in the yard. And it already has 3
phase, and enough 3 phase at that. So we set about making that into a
bakehouse. A lick of paint; some new flooring; wider, taller doorways
so we could get the oven in. Minor stuff like that.

By now we're up to late spring of 2017. I'd given up on trying to
renovate the decks myself, so I got onto Martin Passey at [[http://becketts.co.uk/][Becketts]] and
arranged for them to sort out the electrics and replace the rusty
steel beds with ceramic ones instead, which are generally reckoned to
be the best choice if you want to make 'hearth' breads on the oven
floor. We just needed to work out how to get the oven from Doncaster
to Heywood.

Guess what? It wasn't straightforward.

When we picked up my oven from the Isle of Wight, we'd got it into a
large Luton bodied van with a tail lift, and it was kind of fine. I
suppose I could have hired another one, roped in a few volunteers and
driven it over myself, but the fact that we'd partially assembled the
oven was going to make that rather trickier than it could have been.
Disassembling it was going to be tricky too - after we got the straps
out from the top decks when we'd assembled it, we discovered we'd been
very lucky indeed, and the strap had /very/ nearly broken.

The best option was to get a flatbed truck with a Hiab or similar
hydraulic crane which would make short work of getting the oven up
onto the truck and off to be fettled. But the access (up a 10 foot
wide back lane) proved daunting. All the haulage companies I talked to
took one look at it and backed away, muttering darkly and making the
sign of the cross. "Get a bunch of strong Polish lads to carry it down
the alley and stick it on the back of a truck" was the best (but very
unofficial) suggestion. Not ideal.

So now it's July and I'm chatting to a fellow guest at my brother's
silver wedding anniversary about my shipping woes. "You want to talk
to Dan!" he said.

"Dan?"

"Yeah, [[http://www.danpunchard.co.uk/][Dan Punchard]]. He's great, he's moved a couple of lathes for me
with some really tight access."

"Thanks!"

My informant was not wrong. Dan was brilliant. We exchanged a few
emails and photos of the access and /bang/ the oven was off into the
tender loving care of Becketts for its electrical fettling and new
floors. And soon the money was flowing out of my savings as I bought a
new spiral mixer, wire cooling baskets, steel work table, scales (both
electronic for weighing ingredients into the mixer and a balance
scale, which is /still/ the fastest way of scaling dough when you
divide it), lots of [[https://www.bakerybits.co.uk/bakery-equipment/proving-baskets-and-cloths/wicker-baskets/heavy-duty.html][bannetons]] (probably not enough) from Bakery Bits,
workwear, flour, wire shelving, and a bewildering amount of janitorial
bits and bobs from [[https://nisbets.co.uk/][Nisbets]]. Fettling the oven wasn't exactly cheap,
but wow, do those baskets add up!

*** It's arrived, and it fits

On the 8th of December last year I sent mail Martin some mail with the
subject "It's arrived, and it fits!" and over the next couple of weeks
the rest of the stuff I needed to bake arrived and, on the 20th of
December, I fired up the mixer for batch of 16 loaves and what proved
to be far too many pizza doughballs.

On Friday 21st of December, I pulled my first loaves out of my ~40
year old oven, and /damn/, but they were good.

#+ATTR_HTML: :width 100%
#+CAPTION: The first loaf
[[./back-to-the-bakehouse/first-loaf.jpg]]

*** What next?

    Of course, no enterprise like this is ever finished, here's a
    selection from my to do list.


**** Plumbing
     A bigger sink! Water near the scale so I'm not carrying buckets
     back and forth! A handwash basin!

**** Qualifications
     Environmental Health Officers do like you to have a certificate
     to show you're not a complete moron when it comes to hygiene.
     Breadmaking is relatively low risk because everything gets so
     very hot during the cooking process, but even so.

**** Refrigeration
     Right now everything's at the ambient temperature, which can mean
     staying in the bake house until the early hours in order to get
     the loaves into the oven when they're perfectly proved. A better
     approach would be to stick the dough into a retarder (big
     fridge, racked for standard bakers' sheet pans) and bake them
     first thing in the morning after a decent night's sleep. I have a
     retarder, but transport is annoyingly tricky because it's 2m
     tall, and should ideally be transported vertically too.

**** Fitness
     Right now, I can just about cope with two bakes a week, but if
     I'm going to actually make money at this, I'm going to need to be
     able to manage more. Hopefully, as I bake it'll improve my
     fitness, so as demand grows I'll be able to meet it.

**** Marketing
     Oh boy, do I suck at marketing? Still, the product is good and
     there's nobody else in the local area making this sort of bread,
     so I have a few advantages. I still haven't made a Loafery
     website though. At least I have the loafery.co.uk domain.

**** Online ordering
     If I can get people ordering online, I can use that to produce
     production schedules, and generally have a better idea of how
     much to make on each bake day, which help minimise any wasted
     bread. With two bakes done this year, I've sold every loaf - I'd
     like to keep that up.

*** In the next bakehouse diary...
    I'll talk about how a bake goes and the process of developing an
    initial range of products, sourcing flour and other ingredients
    and hopefully some news about online ordering.




** DRAFT Literate Baking
   :PROPERTIES:
   :EXPORT_DATE: 2018-10-25
   :export_file_name: literate-baking
   :END:

   My baking day goes like this:

I come into the bakehouse, open up Emacs and type =M-m o c B= and up comes the skeleton of an entry for my baking daybook. I review it quickly, then type =C-c C-c=

** DONE Running a bakery on Emacs and PostgreSQL
   :PROPERTIES:
   :EXPORT_FILE_NAME: baking-with-emacs
   :export_hugo_slug: baking-with-emacs
   :export_hugo_custom_front_matter: :series "Bakehouse diary"
   :export_date: 2019-02-25
   :END:

 Just over a year ago now, I finally opened the bakery I'd been dreaming of for years. It's been a big change in my life, from spending all my time sat in front of a computer, to spending most of it making actual stuff. And stuff that makes people happy, at that. It's been a huge change, but I can't think of a single job change that's ever made me as happy as this one.

 #+hugo: more

 One of the big changes that came with going pro was that suddenly I was having to work out how much stuff I needed to mix to fill the orders I needed. On the face of it, this is really simple, just work out how much dough you need, then work out what quantities to mix to make that much dough. Easy. You can do it with a pencil and paper. Or, in traditional bakers' fashion, by scrawling with your finger on a floured work bench.

 And that's how I coped for a few weeks early on. But I kept making mistakes, which makes for an inconsistent product (bread is very forgiving, you have to work quite hard to make something that isn't bread, but consistency /matters/). I needed to automate.

 I'd been on one of Bread Matters' "Baking for a Living" courses and as part of the course materials had received a copy of a spreadsheet that could be used to go from a list of orders to a list of ingredients to mix alongside accurate costings and other useful bits and bobs. It was great and certainly opened my eyes to the possibilities for automation of this part of the job.

 And then I tried to add a new recipe.

 Spreadsheets aren't my favourite computational model so maybe it was just my lack of experience with them, but adding a new recipe was like pulling teeth; lots of tedious copying, pasting and repetition of formulae. It just seemed wrong, especially as the underlying computations were so straightforward (ish). There had to be a better way.

 The key insight is that a bakery formula is so cliched that it can be represented as data. Here's the formula for seedy malt loaves:

 | recipe           | ingredient       | quantity |
 |------------------+------------------+----------|
 | Small Seedy Malt | Seedy malt dough | .61 kg   |
 | Large Seedy Malt | Seedy malt dough | .92 kg   |

 Of course, that's not the full set of formulae, because it doesn't tell you how to make 'Seedy malt dough', but that's just another formula, which consists of flour, water, starter, salt and a multiseed 'soaker', where the starter and the soaker are the results of other formulae, which are (finally) made from basic ingredients[fn:2]. I did consider reaching for the object oriented hammer at this point, but thought that I might be able to do everything I needed without leaving SQL. It was relatively straightforward to move the shape of the calculations in the Bread Matters spreadsheet into my database schema, the only real sticking point being the recursive nature of the formulae, but it turns out that recursive queries are a thing in modern SQL, albeit a little tricky to get absolutely right[fn:3] first time.

 If you're curious[fn:14] about the details of the schema, you can find it in my [[https://github.com/pdcawley/bakehouse][github repo]] for the bakery.

 So now, a few days before a bake, I'd setup my ~production_order~ table with the orders for the bake, and run a query on the ~production_list~ view to find out what I needed to mix when. And all was great. Well, sort of. I had to add a bit extra onto the quantities in the initial starter mix to allow for the bits that get stuck to the bowl and lost to the final dough, and it was all very well until I wanted to bake two days in a row (a bake is a two day process from mixing the starters on a Wednesday evening, through mixing, fermenting and shaping on Thursday to baking the resulting loaves at four on Friday morning). But, vitally, it was much, much easier to add and adjust formulae, and the limitations were no worse than the limitations of the spreadsheet. All was well.

 It's the nature of business that you need to keep records. How much got baked? How much sold? Did we clean the floor? Were there any accidents? What sort? How do we prevent them next time? The list is endless. It all needs to be recorded, for both legal and pragmatic reasons. So I started a day book. This is just an .org file[fn:4]. Every day I come into the bakery, I run ~org-capture~ and I get a template for the day's entry in the daybook, which I fill in as the day goes on.

 One of the features of org-mode is ~org-babel~, a literate programming environment, which lets me write something like:

 #+begin_src org
,#+begin_src sql
SELECT ingredient, quantity
  FROM bakehouse.production_list
 WHERE work_date = 'today';
,#+end_src
 #+end_src

 and then, with the cursor somewhere in the code block, hit ~C-c C-c~ whereupon Emacs will run that SQL against the bakery database and populate a table like:

 | ingredient  | quantity |
 |-------------+----------|
 | Old starter |      1.3 |
 | Water       |     2.08 |
 | White flour |      2.6 |
 | ...         | ...      |

 If that were all org-mode did to assist, it'd be awesome enough, but the queries I make are a little more complex than that, the current version of the database understands about dates and can cope with overlapping bakes, but all that makes the queries a little more complex. Org-mode helps with that too, because I can file away snippets of code in a 'library of babel' and just reference them from the daybook. And I can set arbitrary variables at any point in the hierarchy of the document.

 So I have a bit of code in my emacs config that tweaks the day's entry in a daybook like so:

 #+begin_src emacs-lisp
  (defun pdc//in-bakery-daybook? ()
    "Are we in the bakery daybook?"
    (equal (buffer-name) "CAPTURE-loafery-daybook.org"))

  (defun pdc/set-daybook-entry-properties ()
    "Set the properties we rely on in our boilerplated daybook queries"
    (save-excursion
      (while (not (looking-at "*+ [[:digit:]]\\{4\\}\\(-[[:digit:]]\\{2\\}\\)\\{2\\}"))
        (org-up-element))
      (let ((entry-date (first (s-split " " (org-entry-get (point) "ITEM")))))
        (org-entry-put
         (point)
         "header-args+"
         (format ":var work_date=\"'%s'\"" entry-date)))
      (org-babel-execute-subtree)))

  (defun pdc/org-capture-before-finalize-daybook-entry ()
    (when (pdc//in-bakery-daybook?)
      (pdc/set-daybook-entry-properties)))

  (add-hook 'org-capture-before-finalize-hook
            #'pdc/org-capture-before-finalize-daybook-entry)
 #+end_src

 It won't win any code beauty contests, but it does the job of setting a ~work_date~ variable for the day's entry and running any code in the subtree as part of the capture process. The capture template has lines like ~#+call:mixes()~, which call the stored code snippets, that reference the variable set in the current subtree and so make the query for the right day. This means that all I have to do to know what I should be doing when I get into the bakehouse is to run an org-capture and check the resulting entry in my daybook. Provided, that is, that I've added the appropriate rows to the database.

*** Next steps

 The software isn't done, of course, no software ever is. But it's good enough that it's been managing my mixes without a hitch for the last few months, telling me what to pack for which customer and generally removing the need to work anything out with a pencil and paper. It's nowhere near as mature or capable of commercial production management software, but it fits me. I understand what it does and why, how it does it, the limitations it has and how to work around them. When it becomes annoying enough, I might sit down and work out how to fix it, but I'll do that when I'm in the right frame of mind. My current list of niggles looks something like this:

 - Accounting :: The database already knows how to do costings based on raw ingredient costs etc, but I should probably be able to use it to keep my books as well, using ~org-ledger~
 - Parametric recipes :: At a certain point, it becomes easier to mix a 'stiff starter' in my mixer than it is to just mix the usual wet starter by hand. This breakpoint comes at around 3kg of flour. Right now, I manage this by looking at the mixes for my starters and, if it looks like a lot, changing the order to use 2-stage versions of the formulae and running the query again. I think it should be possible to automate this through a more sophisticated query, but I need to work that out.
 - Better scheduling :: things get weird if a batch of dough would be more than I can mix in a single go. Right now there are other physical limitations that mean that I simply can't make that much bread anyway, but once I get a few more bannetons and racks, this will become a much more pressing issue.
 - Order management :: Right now, I manage orders through Postico talking to the database, which is okay, but a little frustrating in places. An autocompleting environment for orders within emacs would be a much neater way to manage things.

*** Putting the personal in personal computing
 Computers are amazing. They are versatile tools even if you don't know how to program them, because there's almost always an app for what you want, or something close enough that you cant work around its infelicities. It's quite remarkable the things that folks can do with their kit with no programming skill at all.

 But... learn to program, and a whole other vista of possibility opens up to you. With good programmable tooling you're only really limited by your skill and understanding. Instead of accommodating yourself to your software, you can accommodate your software to you, and make the right functionality trade-offs for you. There's a brilliant commercial piece of music looping sofware I use that could be massively more brilliant if there were a way of picking up the tempo automatically from the first recorded loop - it would free me from having to sing to a click and generally make the whole process easier. The developers have other (understandable) priorities, like porting the app to windows. And they're not wrong to do so. There were folk clamoring for a windows version, and if a developer isn't making money from a commercial application, then development will stop. I'm definitely not complaining, the feature is not so dramatically necessary that I'm prepared to spend the time learning how to do real time music programming in order to implement it, but if I want software to dance to /my/ tune then doing it myself is the only way.

 So... choose tools that let you program them. I choose emacs and PostgreSQL, you might choose vim and SQLite or Atom and a NoSQL database, or you might just live in your Smalltalk image. Once you start to see your computing environment as truly soft and malleable, you can do amazing things, assisted by a computer that is truly /yours/.


** DONE "A recipe is just a directed acyclic graph…"
   :PROPERTIES:
   :export_hugo_slug: recursive-sql-recipes
   :export_file_name: recursive-sql-recipes
   :export_date: 2019-03-04
   :export_hugo_custom_front_matter: :series "Bakehouse diary"
   :END:

In [[/2019/02/25/baking-with-emacs][the last post]] I handwaved the way I represented bakery formulae in the bakery database, so here's a little more detail. It helps to think of a bakery formula as a node on a directed acyclic[fn:5] graph with weighted edges, where the weights are literally weights. Here's the graph a for a couple of products

# #+begin_src dot :file formulae.svg :exports none :results file :cmdline -Tsvg
# digraph G {
# rankdir=LR;
# node [shape=box];
# { rank = same; "5 seed soaker"; "80% starter"; }
# { rank = same; node [shape=ellipse]; "water"; "white flour"; "salt"; "malthouse flour";
# "5 seed mix"; }

# "Small Seedy Malt" -> "Seedy Malt Dough" [label="600g"];
# "Small White Wild" -> "Basic White Sour" [label="600g"];

# "Basic White Sour" -> "80% starter" [label="90%"];
# "Basic White Sour" -> "white flour" [label="100%"];
# "Basic White Sour" -> "water" [label="55%"];
# "Basic White Sour" -> "salt" [label="3%"];

# "Seedy Malt Dough" -> "5 seed soaker" [label="50%"];
# "Seedy Malt Dough" -> "80% starter" [label="45%"];
# "Seedy Malt Dough" -> "malthouse flour" [label="100%"];
# "Seedy Malt Dough" -> "water" [label="47.5%"];
# "Seedy Malt Dough" -> "salt" [label="3%"];

# "5 seed soaker" -> "5 seed mix" [label="100%"];
# "5 seed soaker" -> "water" [label="120%"];

# "80% starter" -> "white flour" [label="100%"];
# "80% starter" -> "water" [label="80%"];
# }
# #+end_src

#+RESULTS:
#+begin_RESULTS
[[file:formulae.svg]]
#+end_RESULTS

#+hugo: more

And here's how we represent that in the database[fn:6]:

#+begin_comment
#+begin_src sql :exports results
WITH RECURSIVE f(name,ingredient,amount) AS (
  SELECT recipe, ingredient, amount
    FROM bakehouse.recipe_item
   WHERE recipe IN ('Small Seedy Malt', 'Small White Wild')
 UNION
  SELECT ri.recipe, ri.ingredient, ri.amount
   FROM f
   JOIN bakehouse.recipe_item ri ON ri.recipe = f.ingredient
)
select name, ingredient, format('%s kg', ROUND(amount, 2)) from f order by name;
#+end_src
#+end_comment

#+RESULTS:
| name             | ingredient                    | format  |
|------------------+-------------------------------+---------|
| Small Seedy Malt | Seedy Malt Dough              | 0.63 kg |
| Small White Wild | Basic White Sour              | 0.63 kg |
| Basic White Sour | Organic white flour           | 2.00 kg |
| Basic White Sour | Sea salt                      | 0.06 kg |
| Basic White Sour | Water                         | 1.10 kg |
| Basic White Sour | 80% starter                   | 1.80 kg |
| Seedy Malt Dough | 5 Seed Soaker                 | 4.00 kg |
| Seedy Malt Dough | Water                         | 3.80 kg |
| Seedy Malt Dough | Sea salt                      | 0.22 kg |
| Seedy Malt Dough | 80% starter                   | 3.60 kg |
| Seedy Malt Dough | Organic light malthouse flour | 8.00 kg |
| 5 Seed Soaker    | Water                         | 1.20 kg |
| 5 Seed Soaker    | 5 seed mix                    | 1.00 kg |
| Mother           | Water                         | 3.20 kg |
| Mother           | Organic white flour           | 4.00 kg |

Suppose we have an order for 8 Small White loaves. We need to know how much starter to mix tonight. We know that we need 0.63 kg of dough for each loaf, so that's a total of 5.04 kg of Basic White Sour. The formula for Basic White Sour makes a total of $1.10 + 1.80 + 0.06 + 2.00 = 4.96 \mathrm{kg}$ of dough. So we need to multiply each quantity in that formula by the weight of dough we need divided by the total weight of the recipe $(5.04/4.96 = 1.016)$. This is straightforward enough for flour, water and salt, which are basic ingredients, but we'll need to do a similar calculation to work out how much flour and water we'll need to make $1.016 × 1.8 = 1.829 \mathrm{kg}$ of starter. You can see how this might become a little tedious.

If I were going to be doing these calculations by hand, it would definitely pay me to normalize my intermediate formulae so they all made a total of 1 kg of stuff. But screw that, we have a computer, so we can make it do the work.

I'm going to simplify things a little (the real database understands about dates, and we need to know a little more about recipes, products and ingredients than will fit in the ~recipe_item~ table that describes the graph) but this should give you an idea of the recursive queries that drive production planning.

Let's introduct a ~production_order~ table, where we stash our orders[fn:7]:

| product          | quantity |
|------------------+----------|
| Small White Wild |        5 |
| Small Seedy Malt |        5 |

And that's all we need to fire off a recursive query[fn:8].

#+begin_src sql
WITH RECURSIVE po(product, quantity) AS (
    SELECT 'Small White Wild', 5
  UNION
    SELECT 'Large White Wild', 5
), rw(recipe, weight) AS (
    SELECT recipe, sum(amount)
      FROM bakehouse.recipe_item
  GROUP BY recipe
), job(product, ingredient, quantity) AS (
    SELECT po.product,
           ri.ingredient,
           po.quantity * ri.amount
      FROM po
      JOIN bakehouse.recipe_item ri ON po.product = ri.recipe
      JOIN rw ON ri.recipe = rw.recipe
  UNION
    SELECT job.ingredient, ri.ingredient, job.quantity * ri.amount / rw.weight
      FROM job
      join bakehouse.recipe_item ri on job.ingredient = ri.recipe
      join rw on job.ingredient = rw.recipe
)
SELECT product formula, ingredient, ROUND(sum(quantity),2) quantity from job group by job.product, job.ingredient order by formula;
#+end_src

Which gives the following result:

#+RESULTS:
| formula          | ingredient          | quantity |
|------------------+---------------------+----------|
| Basic White Sour | Sea salt            |     0.09 |
| Basic White Sour | Water               |     1.72 |
| Basic White Sour | Mother              |     2.81 |
| Basic White Sour | Organic white flour |     3.13 |
| Large White Wild | Basic White Sour    |     4.65 |
| Mother           | Organic white flour |     1.56 |
| Mother           | Water               |     1.25 |
| Small White Wild | Basic White Sour    |     3.10 |

A quick sanity check seems to show this is correct (we're making 7.75kg of Basic White Sour, which tallies with the weights needed to make the loaves).
So what's going on in the query? In SQL, ~WITH~ is a way of giving names to your intermediate results, akin to ~let~ in a Lisp. We fake up a table to hold our production orders (~po~) and the ~rw~ clause is totals the weights of all our recipes (in the real database, it's a view). The magic really starts to happen when you use the ~WITH RECURSIVE~ form. With ~RECURSIVE~ in play, the last query is treated differently. Instead of being a simple two part ~UNION~ what happens is that we first run:

#+begin_src sql
SELECT po.product, ri.ingredient, po.quantity * ri.amount
  FROM po
  JOIN bakehouse.recipe_item ri on po.product = ri.recipe
  JOIN rw on ri.recipe = rw.recipe
#+end_src

and call the results ~job~ and then run the second query, adding any extra rows generated to the results, and repeating that query until the result set stops growing. If we didn't have ~WITH RECURSIVE~ available, and we knew the maximum depth of recursion we would need, we could fake it by making a bunch of intermediate clauses in our ~WITH~. In fact, until I worked out how ~WITH RECURSIVE~ works, that's exactly what I did.

Have you spotted the mistake? I didn't, until a few bakes when horribly wrong.

Here's what happens when we have an order for 3 small loaves and two large ones

| formula          | ingredient          | quantity |
|------------------+---------------------+----------|
| Basic White Sour | Sea salt            |     0.02 |
| Basic White Sour | Water               |     0.41 |
| Basic White Sour | Mother              |     0.68 |
| Basic White Sour | Organic white flour |     0.75 |
| Large White Wild | Basic White Sour    |     1.86 |
| Mother           | Organic white flour |     0.38 |
| Mother           | Water               |     0.30 |
| Small White Wild | Basic White Sour    |     1.86 |

We're only making 1.86 kg of dough? What's going on?

It turns out that the way a ~UNION~ works is akin to doing ~SELECT DISTINCT~ on the combined table, so it selects only unique rows. When two orders end up requiring exactly the same amount of the 'same' dough, they get smashed together and we lose half the weight. This is not ideal.[fn:9] I fixed it by adding a 'path' to the query, keeping track of how we arrived at a particular formula. Something like:

#+begin_src sql
WITH RECURSIVE po(product, quantity) AS (
    SELECT 'Small White Wild', 3
  UNION
    SELECT 'Large White Wild', 2
), rw(recipe, weight) AS (
    SELECT recipe, sum(amount)
      FROM bakehouse.recipe_item
  GROUP BY recipe
), job(path, product, ingredient, quantity) AS (
    SELECT po.product,
           po.product,
           ri.ingredient,
           po.quantity * ri.amount
      FROM po
      JOIN bakehouse.recipe_item ri ON po.product = ri.recipe
      JOIN rw ON ri.recipe = rw.recipe
  UNION
    SELECT job.path || '.' || job.ingredient,
           job.ingredient,
           ri.ingredient,
           job.quantity * ri.amount / rw.weight
      FROM job
      join bakehouse.recipe_item ri on job.ingredient = ri.recipe
      join rw on job.ingredient = rw.recipe
)
SELECT product formula, ingredient, round(sum(quantity),2) weight from job group by formula, ingredient order by formula;
#+end_src

This query gives us:

#+RESULTS:
| formula          | ingredient          | weight |
|------------------+---------------------+--------|
| Basic White Sour | Sea salt            |   0.05 |
| Basic White Sour | Water               |   0.83 |
| Basic White Sour | Mother              |   1.35 |
| Basic White Sour | Organic white flour |   1.50 |
| Large White Wild | Basic White Sour    |   1.86 |
| Mother           | Organic white flour |   0.75 |
| Mother           | Water               |   0.60 |
| Small White Wild | Basic White Sour    |   1.86 |


This time we're making 3.74 kg of dough, which is right.

In order to see what's going on, we can change the final ~SELECT~ to ~SELECT formula, path, ingredient, round(quantity,2) weight FROM job~, and now we get:

| formula          | path                                     | ingredient          | weight |
|------------------+------------------------------------------+---------------------+--------|
| Large White Wild | Large White Wild                         | Basic White Sour    |   1.86 |
| Basic White Sour | Large White Wild.Basic White Sour        | Mother              |   0.68 |
| Basic White Sour | Large White Wild.Basic White Sour        | Organic white flour |   0.75 |
| Basic White Sour | Large White Wild.Basic White Sour        | Water               |   0.41 |
| Basic White Sour | Large White Wild.Basic White Sour        | Sea salt            |   0.02 |
| Mother           | Large White Wild.Basic White Sour.Mother | Water               |   0.30 |
| Mother           | Large White Wild.Basic White Sour.Mother | Organic white flour |   0.38 |
| Small White Wild | Small White Wild                         | Basic White Sour    |   1.86 |
| Basic White Sour | Small White Wild.Basic White Sour        | Organic white flour |   0.75 |
| Basic White Sour | Small White Wild.Basic White Sour        | Sea salt            |   0.02 |
| Basic White Sour | Small White Wild.Basic White Sour        | Water               |   0.41 |
| Basic White Sour | Small White Wild.Basic White Sour        | Mother              |   0.68 |
| Mother           | Small White Wild.Basic White Sour.Mother | Organic white flour |   0.38 |
| Mother           | Small White Wild.Basic White Sour.Mother | Water               |   0.30 |

Which shows that we're considering two lots of Basic White Sour with exactly the same weights, but we (and more importantly, the database engine) know that they're distinct amounts because we get to them through different routes. Hurrah! The problem is solved and we can accurately work out what we should be mixing.

** What's still missing

   As a baker, I know that, if I've got an order for bread on Friday, then I need to mix the starters on Wednesday night, then spend Tuesday mixing, fermenting and shaping the loaves, which will spend the night in the retarder ready to be baked at 4 on Friday morning. But the schema I've outlined here doesn't. In my full bakehouse schema, I have a few extra tables which hold timing data and such. In particular, I have a ~product~ table, which knows about everything I sell. This table knows holds info about how many I can make per hour of work and the bake time and temperature. Then there's a ~recipe~ table[fn:10] which holds information about how long a formula needs to rest[fn:11]. The real queries take this into account to allow us to work back from the ~due_date~ of a real order to the day we need to do the work. If you want to dig into how I handle dates[fn:12] you can check out the repository at [[https://github.com/pdcawley/bakehouse/]].

** The perils of writing stuff up

   Never write your work up for your blog. Especially if you're mostly happy with it. As I was writing this, I realised there's an annoying bit of code duplication that I think I can eliminate. In the current code, I repeat what's essentially the same query structure in a couple of different views, but the formula graph is essentially static unless I add or adjust a recipe. Now I'm wondering if I could make a materialised view that has enough information to shortcut the calculations for both making the production list (what needs to be mixed, when) and for working out my costings (to put a price on a loaf, you need to know how much the raw ingredients cost, and that involves walking the tree again. Maybe a table like:

| product          | sub_formula      | ingredient  | factor | lead_time |
|------------------+------------------+-------------+--------+-----------|
| Large White Wild | Basic White Sour | White Flour |  0.403 | 1 day     |
| Large White Wild | Basic White Sour | Salt        |  0.012 | 1 day     |
| Large White Wild | Basic White Sour | Water       |  0.222 | 1 day     |
| Large White Wild | Basic White Sour | 80% Starter |  0.462 | 1 day     |
| Large White Wild | 80% Starter      | White Flour |  0.288 | 2 days    |
| Large White Wild | 80% Starter      | Water       |  0.173 | 2 days    |

If we have that table, then two days before our bread is due, if we have an order for 10 white loaves, we'll need to mix \(9.3 × .288 \approxeq 2.68\) kg of flour and $9.3 × 0.173 \approxeq 1.61$ kg of water. Which we can do with a simple non-recursive ~SELECT~. Something like:[fn:13]

#+begin_src sql
WITH weighted(formula, ingredient, weight, due) AS (
    SELECT precalc.sub_formula,
           precalc.ingredient,
           precalc.factor * po.quantity * rw.weight,
           po.due_date - precalc.lead_time
      FROM precalc
      JOIN production_order po ON precalc.product = po.product
      JOIN recipe_weight rw ON precalc.product = rw.recipe
)
  SELECT formula, ingredient, sum(weight)
    FROM weighted
   WHERE due = 'today'
GROUP BY formula, ingredient
#+end_src

We can use the same table to calculate the raw material costs for a given recipe, using a simple non-recursive query too.

I think, however, I'm going to leave it alone until I have to write another recursive view that walks the same graph, at which point I'll bite the bullet and do the pre-calculated version.


* DONE Asshole Free Devil's Advocacy :philosophy:blether:c
  :properties:
  :export_file_name: devils-advocacy-without-asshattery
  :export_hugo_slug: devils-advocacy-without-tears
  :export_date: 2018-10-25
  :end:


  So, you want to play Devil's Advocate, but you're afraid you might come across as a bit (or a lot) of an asshole? Here's some suggestions for how to avoid that.

#+hugo: more

** Maybe don't?

   Seriously, why does the Devil need an advocate? If you want to play DA because you think the position you want to argue has some merit, then argue the position honestly and own it. If it doesn't survive the discussion (or is shouted down), then "Ah right, I hadn't thought of that, you're right" or words to that effect and file that position in your memory as a bad one (along with the skeleton of /why/ it's bad). Nothing wrong with holding strong opinions, the thing that's bad is holding onto them if they're shown to be bad. If the group you're talking with just shouts you down and doesn't convince you that your position is a bad one, maybe find a different group? Or agree with them to steer clear of that topic.

   What's really intellectually dishonest is to say "I was only playing Devil's Advocate!" after an idea has been shot down. I'm sure your intentions are entirely honorable, but what if they weren't? Say you genuinely held that the best thing to do with the children of the poor was to turn them into cheap and delicious meals for the richest in society. Say you advanced this position to your friends and were utterly appalled by the idea. Then maybe you'd try to distance yourself from it by saying "Whoah! Guys[fn:1]! I was only playing Devil's Advocate!"

   When I hear someone playing that card, how am I supposed to distinguish between the well-meaning "There is this argument I've come across that I'm not sure I agree with, but it maybe has some merit and I don't know how I'd argue convincingly against it" types and the assholes who were flying a kite? Maybe the non-assholes will have friends who'll tell me that "They might seem like a bit of an arse, but they're not really." I've been that guy, and I don't want to be him again. Why is it okay for me to load the work of explaining that I'm not dickhead onto my friends rather than just not acting like a dickhead in the first place? Eventually, friends get tired. Eventually they'll shift to "Yeah, I know he seems like an ass, and he kind of is, but..." and then one day, they won't be your friends any more.



** Be up front

   Before you introduce the idea you want to play Devil's advocate for, say something like "D'you mind if I play Devil's advocate for a moment?" And when the group tells you "Yes, we do mind. Why help the devil?" listen to them. If it's genuinely that you've heard some argument that on the face of it seems repugnant, but you can't find a hole in it, then say as much: "What's wrong with this idea? Clearly feeding poor babies to the 1% is utterly repellant, but I can't find an effective counterargument."

   Don't keep doing it, mind, or you'll start looking like the kite flying asshole again.

* Footnotes

[fn:14] And several of you seem to be, so I wrote [[/2019/03/04/recursive-sql-recipes/][another post]] with a bit more detail and some sample code.

[fn:13] NB: I've not tested this because I don't have the precalculated table, but it seems like it should work. In fact, thinking about it, we could probably build the ~precalc~ table so that we can simply do ~precalc.factor * po.quantity~, since any change that affects recipe weight will also affect our precalculated table.

[fn:12] Which is currently far more complicated than I need it to be. I had optimistic thoughts about doing accurate scheduling within the database, but getting that right is more complicated than I want to think about, and for the limited product range I currently have, it's easy enough to do in my head.

[fn:11] This could be the bulk fermentation time if it's a formula for a dough or a starter, a proof time if it's a loaf, or a soaking time for a soaker (a soaker is usually a mixture of seeds or fruit and a liquid, usually water, but occasionally fruit juice or booze depending on the final product)

[fn:10] Which should really be called the ~formula~ table, I suppose.

[fn:9] It's /especially/ not ideal when you don't spot there's a problem and end up making far fewer loaves than you expect. Or on one /really/ annoying occasion, making a dough that was far too dry because we lost some water along the way. You can correct this during the mix, but it was a nasty shock.

[fn:8] I'm writing this using the literate programming capabilities of org-mode, so the code you see is being run against my production database, and the results are using my working formulae. Which is why we're not querying the real ~production_order~ table.

[fn:7] The real table has extra information about customers and order dates.

[fn:6] This table is the result of a query on my real database, where the quantities are in kg, as opposed to the graph representation which was handrolled and adjusted to use bakers' percentages which is how formulae are traditionally written.

[fn:4] Org-mode is an amazing emacs package that's a sort of outliner/task manager/publishing tool/spreadsheet/diary/literate programming environment. It's bewilderingly capable, and is probably the primary driver of the emacs renaissance as people are coming to the editor for org-mode, and porting the rest of their environment - hence the rise of ~evil-mode~, the emacs vim emulation layer.

[fn:3] A few bakes went a little weird before I finally got things sorted.

[fn:2] with a certain amount of handwaving to deal with the fact that a starter is strictly made with flour, water and starter.

[fn:1]​ I know. But the kind of people who make this move in an argument are usually the kind of people who'd address a mixed group of folk as "guys".

[fn:5] If you ignore the fact that a starter is made of flour, water and starter. Which, of course, we're going to.
